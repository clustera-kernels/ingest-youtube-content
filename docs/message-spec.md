## **Clustera JSON-RPC 2.0 Specification**

### **1. Overview**

This document outlines a specification for using JSON-RPC 2.0 over Apache Kafka. It is designed to facilitate a request/reply pattern where a single request message can result in zero, one, or many response messages.

This version (v2) adds a specification for a **distributed call stack** to enable robust end-to-end tracing of requests as they travel through multiple services.

### **2. Protocol Concepts**

* **Application Protocol:** **JSON-RPC 2.0** is used to structure the content of the request and response messages. Its `id` field is essential for correlating requests with their corresponding responses.
* **Transport Protocol:** **Apache Kafka** is used as the message bus to transmit requests and responses. Kafka's message headers are used for routing and tracing metadata.

---

### **3. Request Format**

A request is a single Kafka message composed of headers and a JSON-RPC payload.

#### **3.1. Kafka Message Headers**

| Header Key | Type | Presence | Description |
| :--- | :--- | :--- | :--- |
| `jsonrpc-reply-to-topics` | string | Optional | A JSON array representing Kafka topics where response messages should be sent. |
| `jsonrpc-call-stack` | string (JSON) | Optional | A JSON array representing the call stack for tracing. **See Section 5.** |
| `jsonrpc-reply-to-partition` | integer | Optional | The specific partition within the `reply-to-topic` to send responses. |
| `jsonrpc-reply-to-key` | string | Optional | The Kafka message key to use for all response messages. |

#### **3.2. Kafka Message Body (JSON-RPC)**

The body of the Kafka message contains a standard JSON-RPC 2.0 Request Object.

```json
{
  "jsonrpc": "2.0",
  "method": "user.processBatch",
  "params": {
    "batch_id": "b-12345",
    "users": [
      {"id": 1, "action": "activate"},
      {"id": 2, "action": "deactivate"}
    ]
  },
  "id": "a7ede224-c173-4338-9336-8566d99ef2a4"
}
```

* **`id` (string | integer | null):** This field is **critical**. It MUST be a unique value for each request. All responses generated by this request will carry the same `id`. If `id` is `null`, the message is a notification, and no response is expected.

---

### **4. Response Format**

For every request that includes an `id`, the processing service may send zero or more response messages. Each response correlates to the request via the JSON-RPC `id`.

#### **4.1. Handling Multiple Responses**

To manage a stream of responses, the `result` field of a successful JSON-RPC response is structured with a `status` and `payload`.

* **`status` (string):** `"STREAMING"` for intermediate responses or `"COMPLETE"` for the final response.
* **`payload` (any):** The actual data for the specific response.

**Example: Intermediate Response**
```json
{
  "jsonrpc": "2.0",
  "result": {
    "status": "STREAMING",
    "payload": { "user_id": 1, "outcome": "activated" }
  },
  "id": "a7ede224-c173-4338-9336-8566d99ef2a4"
}
```

#### **4.2. Error Response**

If an error occurs, a standard JSON-RPC Error Object is sent. It is recommended to include the `trace_id` from the call stack (if present) in the error's `data` field to simplify debugging.

**Example: Error Response with Trace ID**
```json
{
  "jsonrpc": "2.0",
  "error": {
    "code": -32602,
    "message": "Invalid parameters for user_id 2",
    "data": {
      "user_id": 2,
      "reason": "Unknown action: 'deactivate'",
      "trace_id": "trace-abc-123"
    }
  },
  "id": "a7ede224-c173-4338-9336-8566d99ef2a4"
}
```

---

### **5. Distributed Tracing & Call Stack**

To trace a request's journey across multiple services, a call stack is propagated via the `jsonrpc-call-stack` Kafka header. This header contains an array of "stack frames," where each frame represents a single service call in the chain.

#### **5.1. Call Stack Propagation**

1.  **Initiation:** The first service in a chain **creates** the `jsonrpc-call-stack` header with a single frame.
2.  **Propagation:** When a service receives a request, it reads the incoming `jsonrpc-call-stack` header.
3.  **Augmentation:** Before making a downstream call to another service, it **adds a new frame** for the outbound request to the top of the stack.
4.  **Forwarding:** It sends the new request with the **updated** `jsonrpc-call-stack` header.

#### **5.2. `jsonrpc-call-stack` Header Format**

The header's value is a **JSON-encoded string representing an array of objects**. The most recent call is at the end of the array (appended).

#### **5.3. Stack Frame Structure**

Each object in the call stack array is a "frame" and must contain the following keys:

| Key | Type | Description |
| :--- | :--- | :--- |
| `trace_id` | string | A unique identifier for the entire end-to-end transaction. **Remains constant** across all frames in a stack. |
| `span_id` | string | A unique identifier for this specific call/operation. |
| `parent_span_id`| string \| null | The `span_id` of the service that made this call. It is `null` for the first frame in the stack. |
| `service_name` | string | A human-readable name of the service making this call (e.g., `api-gateway`, `user-service`). |
| `request_id` | string \| integer | The JSON-RPC `id` of the request message for this hop. |
| `target_topic` | string | The Kafka topic this request was sent to. |
| `method` | string | The JSON-RPC `method` being invoked for this hop. |
| `timestamp` | string | The ISO 8601 timestamp of when the call was initiated. |
| `params_summary`| object \| null | **Optional.** A summary or non-sensitive subset of the request `params`. **CAUTION:** Avoid including large or sensitive data here to keep headers small and secure. |

#### **5.4. Example Workflow**

1.  `api-gateway` receives an HTTP request and initiates a call to `user-service`.
    * It generates a `trace_id`, a `span_id` (e.g., "span-1"), and the JSON-RPC `id` (e.g., "req-alpha").
    * It creates the initial `jsonrpc-call-stack` header.
2.  `user-service` receives the message. To process it, it must call `auth-service`.
    * It reads the incoming stack.
    * It generates a *new* `span_id` ("span-2") and a new request `id` ("req-beta").
    * It **appends** a new frame to the stack, setting `parent_span_id` to "span-1".
3.  The final `jsonrpc-call-stack` header sent from `user-service` to `auth-service` would look like this (formatted for readability):

```json
[
  {
    "trace_id": "trace-abc-123",
    "span_id": "span-1",
    "parent_span_id": null,
    "service_name": "api-gateway",
    "request_id": "req-alpha",
    "target_topic": "user-service-requests",
    "method": "user.processBatch",
    "timestamp": "2025-06-17T16:30:00.123Z",
    "params_summary": { "batch_size": 2 }
  },
  {
    "trace_id": "trace-abc-123",
    "span_id": "span-2",
    "parent_span_id": "span-1",
    "service_name": "user-service",
    "request_id": "req-beta",
    "target_topic": "auth-service-requests",
    "method": "auth.validateUsers",
    "timestamp": "2025-06-17T16:30:00.456Z",
    "params_summary": null
  }
]
```

---

### **6. SDK Implementation Considerations**

A client-side SDK built on this specification would be responsible for:

1.  **Request Management:**
    * Generating unique request `id`s.
    * Creating a registry to map active `id`s to their requests.
    * Attaching the `jsonrpc-reply-to-*` headers.

2.  **Response Handling:**
    * Consuming from reply topics and correlating responses via the `id`.
    * Aggregating streaming responses until a `"COMPLETE"` status or an `error` is received.
    * Implementing request timeouts.

3.  **Call Stack Management:**
    * **Initiating:** If no call stack exists, create the initial header and frame.
    * **Propagating:** Automatically read an incoming stack, append a new frame for any outgoing requests, and attach the updated header.
    * Providing easy access to the current `trace_id` for logging and error reporting.